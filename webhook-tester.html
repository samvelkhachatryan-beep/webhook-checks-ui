<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
  <meta name="theme-color" content="#0a0a0a">
  <meta name="mobile-web-app-capable" content="yes">
  <title>Magic Flow Webhook Tester</title>
  <style>
    :root {
      --bg-primary: #0a0a0a;
      --bg-secondary: #141414;
      --bg-tertiary: #1e1e1e;
      --text-primary: #f0f0f0;
      --text-secondary: #888;
      --accent: #00d4ff;
      --accent-hover: #00b8e6;
      --success: #00ff88;
      --error: #ff4466;
      --warning: #ffaa00;
      --border: #2a2a2a;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html {
      overflow-x: hidden;
    }

    body {
      font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      padding: 2rem;
      overflow-x: hidden;
      width: 100%;
      max-width: 100vw;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    h1 {
      font-size: 2.5rem;
      margin-bottom: 0.5rem;
      background: linear-gradient(90deg, var(--accent), #ff00aa);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .subtitle {
      color: var(--text-secondary);
      margin-bottom: 2rem;
      font-size: 0.9rem;
    }

    .control-panel {
      background: var(--bg-secondary);
      padding: 2rem;
      border-radius: 12px;
      border: 1px solid var(--border);
      margin-bottom: 2rem;
    }

    .manual-test-section {
      margin-bottom: 1.5rem;
    }

    input[type="text"]:focus {
      border-color: var(--accent);
    }

    input[type="text"]::placeholder {
      color: var(--text-secondary);
      opacity: 0.6;
    }

    .button-group {
      display: flex;
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    button {
      padding: 1rem 2rem;
      font-size: 1rem;
      font-family: inherit;
      font-weight: 600;
      background: var(--accent);
      color: var(--bg-primary);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      flex: 1;
    }

    button:hover:not(:disabled) {
      background: var(--accent-hover);
      transform: translateY(-2px);
    }

    button:active:not(:disabled) {
      transform: translateY(0);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    button.secondary {
      background: var(--bg-tertiary);
      color: var(--text-primary);
      border: 1px solid var(--border);
    }

    button.secondary:hover:not(:disabled) {
      background: var(--border);
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-top: 1.5rem;
    }

    .stat-card {
      background: var(--bg-tertiary);
      padding: 1.5rem;
      border-radius: 8px;
      border: 1px solid var(--border);
    }

    .stat-label {
      font-size: 0.75rem;
      text-transform: uppercase;
      color: var(--text-secondary);
      margin-bottom: 0.5rem;
      letter-spacing: 1px;
    }

    .stat-value {
      font-size: 2rem;
      font-weight: 700;
    }

    .stat-value.success {
      color: var(--success);
    }

    .stat-value.error {
      color: var(--error);
    }

    .stat-value.pending {
      color: var(--warning);
    }

    .stat-value.total {
      color: var(--accent);
    }

    .progress-section {
      background: var(--bg-secondary);
      padding: 2rem;
      border-radius: 12px;
      border: 1px solid var(--border);
      margin-bottom: 2rem;
      display: none;
    }

    .progress-section.visible {
      display: block;
    }

    .progress-bar-container {
      background: var(--bg-tertiary);
      height: 8px;
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 1rem;
    }

    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), #ff00aa);
      width: 0%;
      transition: width 0.3s ease;
    }

    .progress-text {
      text-align: center;
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    .report-link-section {
      margin-top: 1.5rem;
      padding: 1rem;
      background: var(--bg-tertiary);
      border-radius: 8px;
      border: 1px solid var(--border);
      text-align: center;
      display: none;
    }

    .report-link-section.visible {
      display: block;
    }

    .report-link-section a {
      color: var(--accent);
      text-decoration: none;
      font-weight: 600;
      font-size: 0.95rem;
    }

    .report-link-section a:hover {
      text-decoration: underline;
    }

    .logs-container {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem;
      max-height: 200px;
      overflow-y: auto;
      font-size: 0.75rem;
      color: var(--text-secondary);
      margin-top: 1rem;
      font-family: 'Courier New', monospace;
    }

    .log-entry {
      padding: 0.25rem 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .log-entry:last-child {
      border-bottom: none;
    }

    .log-entry.success {
      color: var(--success);
    }

    .log-entry.error {
      color: var(--error);
    }

    .results-section {
      background: var(--bg-secondary);
      padding: 2rem;
      border-radius: 12px;
      border: 1px solid var(--border);
      display: block !important;
    }

    .results-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
    }

    h2 {
      font-size: 1.5rem;
      color: var(--text-primary);
    }

    .filter-buttons {
      display: flex;
      gap: 0.5rem;
    }

    .filter-btn {
      padding: 0.5rem 1rem;
      font-size: 0.875rem;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-secondary);
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.2s;
    }

    .filter-btn:hover {
      background: var(--border);
    }

    .filter-btn.active {
      background: var(--accent);
      color: var(--bg-primary);
      border-color: var(--accent);
    }

    .results-grid {
      display: grid;
      gap: 1rem;
    }

    .result-card {
      background: var(--bg-tertiary);
      border-radius: 8px;
      border: 1px solid var(--border);
      overflow: hidden;
      transition: all 0.2s;
    }

    .result-card:hover {
      border-color: var(--accent);
    }

    .result-card.failed {
      border-color: var(--error);
    }

    .result-card.success {
      border-color: var(--success);
    }

    .result-card.retrying {
      border-color: var(--warning);
      opacity: 0.7;
    }

    .result-header {
      padding: 1rem;
      background: var(--bg-primary);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .webhook-info {
      flex: 1;
    }

    .webhook-title {
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 0.25rem;
    }

    .webhook-id {
      font-size: 0.75rem;
      color: var(--text-secondary);
      font-family: monospace;
    }

    .status-badge {
      padding: 0.5rem 1rem;
      border-radius: 6px;
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
    }

    .status-badge.success {
      background: rgba(0, 255, 136, 0.15);
      color: var(--success);
    }

    .status-badge.failed {
      background: rgba(255, 68, 102, 0.15);
      color: var(--error);
    }

    .status-badge.retrying {
      background: rgba(255, 170, 0, 0.15);
      color: var(--warning);
    }

    .retry-btn {
      padding: 0.5rem 1rem;
      font-size: 0.85rem;
      background: var(--accent);
      color: var(--bg-primary);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }

    .retry-btn:hover:not(:disabled) {
      background: var(--accent-hover);
      transform: translateY(-2px);
    }

    .retry-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .retry-status {
      margin-top: 1rem;
      padding: 0.75rem;
      background: var(--bg-primary);
      border-radius: 6px;
      font-size: 0.85rem;
      text-align: center;
    }

    .retry-status.loading {
      color: var(--warning);
    }

    .retry-status.success {
      color: var(--success);
    }

    .retry-status.error {
      color: var(--error);
    }

    .error-group {
      margin-bottom: 1.5rem;
      background: var(--bg-tertiary);
      border-radius: 8px;
      border: 1px solid var(--border);
      overflow: hidden;
    }

    .error-group-header {
      padding: 1rem 1.5rem;
      background: var(--bg-card);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: background 0.2s;
      border-left: 4px solid var(--error);
    }

    .error-group-header:hover {
      background: var(--bg-secondary);
    }

    .error-icon {
      font-size: 1.2rem;
      margin-right: 0.5rem;
    }

    .error-message {
      color: var(--text-primary);
      font-weight: 600;
      font-size: 0.95rem;
    }

    .error-count {
      padding: 0.25rem 0.75rem;
      background: rgba(255, 68, 102, 0.15);
      color: var(--error);
      border-radius: 6px;
      font-size: 0.85rem;
      font-weight: 600;
    }

    .expand-icon {
      color: var(--text-secondary);
      font-size: 0.8rem;
      transition: transform 0.2s;
    }

    .error-group.expanded .expand-icon {
      transform: rotate(180deg);
    }

    .error-group-content {
      display: none;
      padding: 1rem;
      background: var(--bg-primary);
    }

    .error-group.expanded .error-group-content {
      display: block;
    }

    .error-group .result-card {
      margin-bottom: 1rem;
    }

    .error-group .result-card:last-child {
      margin-bottom: 0;
    }

    .group-toggle-btn {
      padding: 0.5rem 1rem;
      font-size: 0.85rem;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: 600;
    }

    .group-toggle-btn:hover {
      background: var(--border);
    }

    .group-toggle-btn.active {
      background: var(--accent);
      color: var(--bg-primary);
      border-color: var(--accent);
    }

    .history-dropdown {
      position: absolute;
      top: calc(100% + 0.5rem);
      right: 0;
      background: var(--bg-primary);
      border: 1px solid var(--accent);
      border-radius: 8px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8), 0 0 0 1000px rgba(0, 0, 0, 0.5);
      min-width: 450px;
      max-height: 500px;
      overflow: hidden;
      z-index: 9999;
      display: none;
    }

    .history-dropdown.visible {
      display: block;
      animation: slideDown 0.2s ease;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .history-dropdown-header {
      padding: 1rem 1.5rem;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      font-weight: 600;
      font-size: 0.9rem;
      color: var(--text-primary);
    }

    .history-dropdown-content {
      max-height: 400px;
      overflow-y: auto;
    }

    .history-loading {
      padding: 2rem;
      text-align: center;
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    .history-item {
      padding: 1rem 1.5rem;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      transition: background 0.2s;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .history-item:last-child {
      border-bottom: none;
    }

    .history-item:hover {
      background: var(--bg-secondary);
    }

    .history-item-info {
      flex: 1;
    }

    .history-item-name {
      font-size: 0.85rem;
      color: var(--accent);
      font-family: monospace;
      margin-bottom: 0.25rem;
    }

    .history-item-date {
      font-size: 0.75rem;
      color: var(--text-secondary);
    }

    .history-item-size {
      font-size: 0.75rem;
      color: var(--text-secondary);
      padding: 0.25rem 0.5rem;
      background: var(--bg-tertiary);
      border-radius: 4px;
    }

    .history-empty {
      padding: 2rem;
      text-align: center;
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    .result-content {
      padding: 1rem;
    }

    .media-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 1rem;
    }

    .media-item {
      background: var(--bg-primary);
      border-radius: 8px;
      padding: 1rem;
      border: 1px solid var(--border);
    }

    .media-type {
      display: inline-block;
      padding: 0.25rem 0.5rem;
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      background: rgba(0, 212, 255, 0.15);
      color: var(--accent);
      border-radius: 4px;
      margin-bottom: 0.75rem;
    }

    .media-preview img {
      width: 100%;
      height: 200px;
      object-fit: cover;
      border-radius: 6px;
      margin-bottom: 0.5rem;
    }

    .media-preview video {
      width: 100%;
      max-height: 200px;
      object-fit: cover;
      border-radius: 6px;
      margin-bottom: 0.5rem;
      background: var(--bg-primary);
    }

    .media-link {
      font-size: 0.7rem;
      color: var(--accent);
      text-decoration: none;
      word-break: break-all;
      display: block;
    }

    .media-link:hover {
      text-decoration: underline;
    }

    .error-message {
      padding: 1rem;
      background: rgba(255, 68, 102, 0.1);
      border: 1px solid var(--error);
      border-radius: 6px;
      color: var(--error);
      font-size: 0.875rem;
    }

    .no-results {
      text-align: center;
      padding: 3rem;
      color: var(--text-secondary);
    }

    .spinner {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin-left: 0.5rem;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: var(--bg-primary);
    }

    ::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--text-secondary);
    }

    /* Mobile Responsive Styles */
    @media (max-width: 768px) {
      body {
        padding: 1rem;
      }

      .container {
        max-width: 100%;
      }

      h1 {
        font-size: 1.75rem;
        margin-bottom: 1rem;
      }

      .header {
        padding: 1.5rem 1rem;
      }

      .input-section {
        padding: 1rem;
        margin-bottom: 1rem;
      }

      .input-group {
        flex-direction: column;
        gap: 0.75rem;
      }

      .input-group input {
        width: 100%;
      }

      .manual-test-row {
        flex-direction: column !important;
        gap: 0.75rem !important;
      }

      .manual-input {
        width: 100% !important;
        min-width: 100% !important;
        flex: none !important;
      }

      .test-selected-btn {
        width: 100%;
        padding: 0.75rem 1rem !important;
      }

      .control-buttons {
        flex-direction: column;
        gap: 0.75rem;
        align-items: stretch;
      }

      .control-buttons button {
        width: 100%;
        justify-content: center;
      }

      .button-group {
        flex-direction: column;
        gap: 0.75rem;
      }

      .button-group button {
        width: 100%;
      }

      .stats-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 0.75rem;
        margin-bottom: 1.5rem;
      }

      .stat-card {
        padding: 1rem;
        min-height: auto;
      }

      .stat-value {
        font-size: 1.75rem;
        margin-bottom: 0.25rem;
      }

      .stat-label {
        font-size: 0.75rem;
        letter-spacing: 0.5px;
      }

      .results-section {
        padding: 1rem;
      }

      .results-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 1rem;
        margin-bottom: 1.5rem;
      }

      .results-header h2 {
        font-size: 1.25rem;
        width: 100%;
      }

      .results-title {
        font-size: 1.25rem;
      }

      .filter-buttons {
        width: 100%;
        flex-wrap: wrap;
        gap: 0.5rem;
        justify-content: stretch;
      }

      .filter-btn {
        flex: 1 1 calc(50% - 0.25rem);
        min-width: calc(50% - 0.25rem);
        justify-content: center;
        padding: 0.65rem 0.75rem;
        font-size: 0.85rem;
      }

      .no-results {
        padding: 2rem 1rem;
        font-size: 0.9rem;
      }

      .results-grid {
        grid-template-columns: 1fr;
        gap: 1rem;
      }

      .result-card {
        margin-bottom: 1rem;
      }

      .card-header {
        padding: 1rem;
        flex-direction: column;
        align-items: flex-start;
        gap: 0.75rem;
      }

      .card-title {
        font-size: 1rem;
      }

      .card-badges {
        flex-wrap: wrap;
        width: 100%;
      }

      .result-content {
        padding: 1rem;
      }

      .media-grid {
        grid-template-columns: 1fr;
      }

      .progress-section {
        padding: 1rem;
        border-radius: 8px;
      }

      .progress-bar-container {
        margin-bottom: 0.75rem;
      }

      .progress-text {
        font-size: 0.85rem;
        margin-bottom: 0.75rem;
        word-break: break-word;
      }

      .logs-container {
        font-size: 0.7rem;
        max-height: 200px;
        line-height: 1.4;
      }

      .history-dropdown {
        min-width: 95vw;
        max-width: 95vw;
        right: auto;
        left: 50%;
        transform: translateX(-50%);
      }

      /* Touch-friendly tap targets (minimum 44x44px) */
      button {
        min-height: 44px;
        touch-action: manipulation;
      }

      .retry-btn,
      .filter-btn {
        min-height: 44px;
      }

      .report-link-section {
        font-size: 0.85rem;
      }

      #shareReportBtn {
        width: 100%;
        margin-top: 0.75rem;
      }
    }

    /* Extra small mobile devices */
    @media (max-width: 480px) {
      body {
        padding: 0.5rem;
      }

      h1 {
        font-size: 1.5rem;
      }

      .stats-grid {
        grid-template-columns: 1fr;
        gap: 0.5rem;
      }

      .stat-card {
        padding: 0.85rem;
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
      }

      .stat-value {
        font-size: 1.75rem;
        order: 2;
      }

      .stat-label {
        font-size: 0.8rem;
        order: 1;
        text-align: left;
      }

      .filter-btn {
        flex: 1 1 100%;
        min-width: 100%;
        max-width: 100%;
        font-size: 0.85rem;
      }

      .results-section {
        padding: 0.75rem;
      }

      .results-header {
        gap: 0.75rem;
        margin-bottom: 1rem;
      }

      .results-header h2 {
        font-size: 1.1rem;
      }

      .results-title {
        font-size: 1.1rem;
      }

      .no-results {
        padding: 1.5rem 0.75rem;
        font-size: 0.85rem;
        line-height: 1.5;
      }

      .manual-test-row {
        gap: 0.5rem !important;
      }

      .manual-input {
        font-size: 0.85rem !important;
        padding: 0.65rem 0.85rem !important;
      }

      .test-selected-btn {
        font-size: 0.85rem;
        padding: 0.65rem 0.85rem !important;
      }

      .card-badges {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.5rem;
      }

      .stat-card {
        padding: 0.75rem;
      }

      .stat-value {
        font-size: 1.5rem;
      }

      button {
        padding: 0.65rem 1rem;
        font-size: 0.9rem;
      }

      .input-section {
        padding: 0.75rem;
      }

      .progress-section {
        padding: 0.75rem;
        border-radius: 8px;
      }

      .progress-text {
        font-size: 0.8rem;
      }

      .result-card {
        border-radius: 8px;
      }

      .card-header {
        padding: 0.75rem;
      }

      .card-title {
        font-size: 0.9rem;
        word-break: break-word;
      }

      .card-subtitle {
        font-size: 0.75rem;
      }

      .media-preview img,
      .media-preview video {
        max-height: 150px;
      }

      .url-text {
        font-size: 0.65rem;
        word-break: break-all;
      }

      input[type="text"] {
        font-size: 16px;
        /* Prevents iOS zoom on focus */
      }

      textarea {
        font-size: 16px;
        /* Prevents iOS zoom on focus */
      }

      .logs-container {
        font-size: 0.65rem;
        padding: 0.75rem;
      }

      .error-message {
        padding: 1rem;
        font-size: 0.85rem;
        word-break: break-word;
      }

      .retry-status {
        font-size: 0.85rem;
        padding: 1rem;
      }

      #shareReportBtn {
        width: 100%;
        padding: 0.75rem;
        margin-top: 0.5rem;
      }

      .report-link-section {
        padding: 1rem;
        text-align: center;
      }

      .report-link-section p {
        margin: 0.5rem 0;
        word-break: break-all;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>üé® Magic Flow Webhook Tester</h1>
    <p class="subtitle">Run and monitor webhook tests in real-time</p>

    <div class="control-panel">
      <div class="manual-test-section">
        <label for="manualWebhookIds"
          style="display: block; margin-bottom: 0.5rem; color: var(--text-secondary); font-size: 0.9rem;">
          Manual Webhook Testing (comma-separated IDs):
        </label>
        <div class="manual-test-row" style="display: flex; gap: 1rem; flex-wrap: wrap;">
          <input type="text" id="manualWebhookIds"
            placeholder="e.g., 69314bdfe9637d9ac5140f33, 69315262b5bc5942e3edd5aa, ..." class="manual-input"
            style="flex: 1; min-width: 200px; padding: 0.75rem 1rem; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 0.9rem; outline: none; font-family: monospace;" />
          <button type="button" class="test-selected-btn" onclick="runManualTests()"
            style="padding: 0.75rem 2rem; white-space: nowrap;">
            üéØ Test Selected
          </button>
        </div>
        <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-secondary);">
          üí° Tip: Enter one or more webhook IDs separated by commas
        </div>
      </div>

      <div style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid var(--border);">
        <div class="button-group">
          <button type="button" id="runAllBtn" onclick="runAllTests()">
            <span id="runBtnText">üöÄ Run All Webhook Tests</span>
          </button>
          <button type="button" id="resumeBtn" class="secondary" onclick="resumeTests()" style="display: none;">
            ‚ñ∂Ô∏è Resume Test
          </button>
          <button type="button" class="secondary" onclick="clearResults()">üóëÔ∏è Clear Results</button>
          <button type="button" class="secondary" onclick="viewAllReports()">
            üìã View All Reports
          </button>
        </div>
      </div>

      <div class="stats-grid">
        <div class="stat-card">
          <div class="stat-label">Total</div>
          <div class="stat-value total" id="totalCount">0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Passed</div>
          <div class="stat-value success" id="passedCount">0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Failed</div>
          <div class="stat-value error" id="failedCount">0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Duration</div>
          <div class="stat-value" id="duration">0s</div>
        </div>
      </div>
    </div>

    <div class="progress-section" id="progressSection">
      <div class="progress-bar-container">
        <div class="progress-bar" id="progressBar"></div>
      </div>
      <div class="progress-text" id="progressText">Initializing...</div>
      <div class="logs-container" id="logsContainer"></div>
      <div class="report-link-section" id="reportLinkSection">
        <p>üìÑ Report saved: <a id="reportLink" href="#" target="_blank">View Report</a></p>
        <button type="button" id="shareReportBtn" onclick="shareReport()"
          style="margin-top: 0.5rem; padding: 0.5rem 1rem; background: var(--accent); color: var(--bg-primary); border: none; border-radius: 6px; cursor: pointer; font-size: 0.85rem; display: none;">
          üìã Copy Shareable Link
        </button>
        <p style="margin-top: 0.5rem;">üìã <a href="/reports/index.html" target="_blank">View All Reports</a></p>
      </div>
    </div>

    <div class="results-section" id="resultsSection">
      <div class="results-header">
        <h2>Test Results</h2>
        <div class="filter-buttons">
          <button type="button" class="filter-btn active" onclick="filterResults('all')" data-filter="all">All</button>
          <button type="button" class="filter-btn" onclick="filterResults('passed')"
            data-filter="passed">Passed</button>
          <button type="button" class="filter-btn" onclick="filterResults('failed')"
            data-filter="failed">Failed</button>
          <button type="button" class="group-toggle-btn" id="groupToggleBtn" onclick="toggleGrouping()">üìë Group
            Errors</button>
        </div>
      </div>
      <div class="results-grid" id="resultsGrid">
        <div class="no-results">Click "Run All Webhook Tests" to begin testing</div>
      </div>
    </div>
  </div>

  <script>
    // Auto-detect environment and set API base URL
    const isLocal = window.location.hostname === 'localhost' ||
      window.location.hostname === '127.0.0.1' ||
      window.location.hostname === '';
    const API_BASE_URL = isLocal
      ? 'http://localhost:3000'
      : 'https://webhook-checks-ui.vercel.app';

    console.log('Environment:', isLocal ? 'LOCAL' : 'PRODUCTION');
    console.log('API Base URL:', API_BASE_URL);

    let testResults = [];
    let currentFilter = 'all';
    let startTime = null;
    let durationInterval = null;
    let isTestRunning = false;
    let groupByError = false;
    let totalWebhooksCount = 0;
    let testCompleted = false; // Flag to prevent clearing after completion
    const retryingWebhooks = new Set(); // Track webhooks currently being retried

    // Client-side test history
    function saveTestToHistory() {
      try {
        const history = JSON.parse(localStorage.getItem('testHistory') || '[]');
        const testRun = {
          id: Date.now(),
          timestamp: new Date().toISOString(),
          date: new Date().toLocaleString(),
          totalWebhooks: testResults.length,
          passed: testResults.filter(r => r.status === 'success').length,
          failed: testResults.filter(r => r.status === 'failed').length,
          duration: document.getElementById('duration').textContent,
          results: testResults
        };

        history.unshift(testRun); // Add to beginning

        // Keep only last 50 test runs
        if (history.length > 50) {
          history.splice(50);
        }

        localStorage.setItem('testHistory', JSON.stringify(history));
        console.log('Test saved to history. Total history:', history.length);
      } catch (e) {
        console.error('Failed to save test to history:', e);
      }
    }

    function loadTestHistory() {
      try {
        return JSON.parse(localStorage.getItem('testHistory') || '[]');
      } catch (e) {
        console.error('Failed to load test history:', e);
        return [];
      }
    }

    // Restore previous session on load
    window.addEventListener('DOMContentLoaded', () => {
      // CRITICAL: Clear any running interval first
      if (durationInterval) {
        clearInterval(durationInterval);
        durationInterval = null;
        console.log('Cleared any existing duration interval');
      }

      const savedResults = localStorage.getItem('testResults');
      const savedStartTime = localStorage.getItem('startTime');
      const savedTotal = localStorage.getItem('totalWebhooksCount');
      const wasRunning = localStorage.getItem('isTestRunning') === 'true';
      const wasCompleted = localStorage.getItem('testCompleted') === 'true';

      // Restore testCompleted state to prevent timer from restarting
      if (wasCompleted) {
        testCompleted = true;
        console.log('Restored testCompleted: true - timer will NOT restart');
      }

      if (savedResults) {
        try {
          testResults = JSON.parse(savedResults);
          if (testResults.length > 0) {
            updateStats();
            displayResults();
            console.log(`Restored ${testResults.length} results from previous session`);

            // Show resume button if we were in the middle of a test
            if (savedTotal) {
              totalWebhooksCount = parseInt(savedTotal);
              if (wasRunning && testResults.length < totalWebhooksCount) {
                document.getElementById('resumeBtn').style.display = 'block';
                log(`Test was interrupted. ${testResults.length}/${totalWebhooksCount} completed.`, 'info');
                log('Click "Resume Test" to continue testing remaining webhooks.', 'info');
              }
            }
          }
        } catch (e) {
          console.error('Failed to restore results:', e);
        }
      }

      if (savedStartTime && !wasRunning && wasCompleted) {
        // Only restore timer if test was completed (not still running)
        // Display the final duration, but don't start ticking again
        startTime = parseInt(savedStartTime);
        updateDuration(); // Update once, but don't keep ticking
        console.log('Restored final duration:', document.getElementById('duration').textContent);
      } else if (savedStartTime && !wasCompleted) {
        // Test was in progress but not completed - clear the saved time
        localStorage.removeItem('startTime');
        startTime = null;
        console.log('Cleared incomplete test start time');
      }
    });

    // Warn before closing ONLY during active test
    window.addEventListener('beforeunload', (e) => {
      console.log('Page unload event. isTestRunning:', isTestRunning, 'testCompleted:', testCompleted);

      // Only warn if test is actively running (not completed)
      if (isTestRunning && !testCompleted) {
        console.log('‚ö†Ô∏è Warning user: test is still running');
        e.preventDefault();
        e.returnValue = 'Test is still running. Are you sure you want to leave?';
        return e.returnValue;
      }

      // After completion, allow reload without warning
      // Results will be restored from localStorage anyway
      console.log('Test completed or not running. Allowing reload without warning.');
    });

    // Save results to localStorage
    function saveResults() {
      try {
        localStorage.setItem('testResults', JSON.stringify(testResults));
        if (startTime) {
          localStorage.setItem('startTime', startTime.toString());
        }
        if (totalWebhooksCount > 0) {
          localStorage.setItem('totalWebhooksCount', totalWebhooksCount.toString());
        }
        localStorage.setItem('isTestRunning', isTestRunning.toString());
        localStorage.setItem('testCompleted', testCompleted.toString());
      } catch (e) {
        console.error('Failed to save results:', e);
      }
    }

    // Clear saved results
    function clearSavedResults() {
      localStorage.removeItem('testResults');
      localStorage.removeItem('startTime');
      localStorage.removeItem('totalWebhooksCount');
      localStorage.removeItem('testCompleted');
      localStorage.removeItem('isTestRunning');
    }

    function log(message, type = 'info') {
      const logsContainer = document.getElementById('logsContainer');
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      logsContainer.appendChild(entry);
      logsContainer.scrollTop = logsContainer.scrollHeight;
    }

    function updateStats() {
      const passed = testResults.filter(r => r.status === 'success').length;
      const failed = testResults.filter(r => r.status === 'failed').length;

      document.getElementById('totalCount').textContent = testResults.length;
      document.getElementById('passedCount').textContent = passed;
      document.getElementById('failedCount').textContent = failed;

      // Save to localStorage
      saveResults();
    }

    function updateProgress(current, total) {
      const percent = (current / total) * 100;
      document.getElementById('progressBar').style.width = percent + '%';
      document.getElementById('progressText').textContent =
        `Testing webhooks: ${current} / ${total} (${Math.round(percent)}%)`;
    }

    function updateDuration() {
      if (startTime && !testCompleted) {
        const elapsed = Math.floor((Date.now() - startTime) / 1000);
        document.getElementById('duration').textContent = elapsed + 's';
      }
    }

    function stopDuration() {
      console.log('Stopping duration timer');
      if (durationInterval) {
        clearInterval(durationInterval);
        durationInterval = null;
        console.log('Duration interval cleared');
      }
      // Update one final time to show final duration
      if (startTime) {
        const elapsed = Math.floor((Date.now() - startTime) / 1000);
        document.getElementById('duration').textContent = elapsed + 's';
        console.log('Final duration:', elapsed + 's');
      }
    }

    function displayResults() {
      const grid = document.getElementById('resultsGrid');
      const resultsSection = document.getElementById('resultsSection');

      console.log('displayResults called. Total results:', testResults.length, 'Filter:', currentFilter);

      // Ensure results section is always visible
      if (resultsSection) {
        resultsSection.style.display = 'block';
      }

      let filtered = testResults;
      if (currentFilter === 'passed') {
        filtered = testResults.filter(r => r.status === 'success');
      } else if (currentFilter === 'failed') {
        filtered = testResults.filter(r => r.status === 'failed');
      }

      console.log('Filtered results:', filtered.length);

      if (filtered.length === 0) {
        if (testResults.length > 0) {
          grid.innerHTML = '<div class="no-results">No results match the current filter</div>';
        } else {
          grid.innerHTML = '<div class="no-results">No results yet. Run a test to see results here.</div>';
        }
        return;
      }

      let html = '';

      // Group by error if showing failed and groupByError is enabled
      if (currentFilter === 'failed' && groupByError && filtered.length > 0) {
        html = renderGroupedFailures(filtered);
      } else {
        // Regular display
        filtered.forEach((result, index) => {
          html += renderResultCard(result);
        });
      }

      console.log('Setting grid HTML with', filtered.length, 'cards');
      console.log('HTML length:', html.length, 'characters');
      grid.innerHTML = html;
      console.log('Grid HTML updated. Grid has', grid.children.length, 'children');
      console.log('Grid element:', grid);
      console.log('Grid offsetHeight:', grid.offsetHeight, 'Grid offsetWidth:', grid.offsetWidth);
    }

    function renderResultCard(result) {
      const isRetrying = retryingWebhooks.has(result.webhookId);
      const statusClass = isRetrying ? 'retrying' : (result.status === 'success' ? 'success' : 'failed');
      const title = result.title || result.slug || 'Untitled';
      const cardId = `card-${result.webhookId}`;

      // If retrying, preserve the existing card's content
      if (isRetrying) {
        const existingCard = document.getElementById(cardId);
        if (existingCard) {
          // Return the existing card's HTML to preserve retry state
          return existingCard.outerHTML;
        }
      }

      return `
        <div class="result-card ${statusClass}" id="${cardId}">
          <div class="result-header">
            <div class="webhook-info">
              <div class="webhook-title">
                ${escapeHtml(title)}
                ${result.category ? `<span style="margin-left: 0.5rem; padding: 0.25rem 0.5rem; background: rgba(0, 212, 255, 0.15); color: var(--accent); border-radius: 4px; font-size: 0.75rem; font-weight: 500;">${escapeHtml(result.category)}</span>` : ''}
              </div>
              <div class="webhook-id">${escapeHtml(result.webhookId)}</div>
            </div>
            <div style="display: flex; align-items: center; gap: 1rem;">
              <div class="status-badge ${statusClass}">
                ${result.status === 'success' ? '‚úì Passed' : '‚úó Failed'}
              </div>
              ${result.status === 'failed' && !isRetrying ? `
                <button type="button" class="retry-btn" onclick="retryWebhook('${escapeHtml(result.webhookId)}', '${escapeHtml(result.slug || '')}', '${escapeHtml(result.title || '')}')">
                  üîÑ Retry
                </button>
              ` : ''}
            </div>
          </div>
          <div class="result-content">
            ${result.status === 'success' ? renderMediaResults(result.results) : renderError(result.error)}
          </div>
        </div>
      `;
    }

    function renderGroupedFailures(failedResults) {
      // Group by error message
      const groups = {};
      failedResults.forEach(result => {
        const errorKey = normalizeError(result.error || 'Unknown error');
        if (!groups[errorKey]) {
          groups[errorKey] = [];
        }
        groups[errorKey].push(result);
      });

      // Sort groups by count (most common errors first)
      const sortedGroups = Object.entries(groups).sort((a, b) => b[1].length - a[1].length);

      let html = '';
      sortedGroups.forEach(([errorMsg, webhooks], groupIndex) => {
        const groupId = `error-group-${groupIndex}`;
        html += `
          <div class="error-group" id="${groupId}">
            <div class="error-group-header" onclick="toggleErrorGroup('${groupId}')">
              <div>
                <span class="error-icon">‚ö†Ô∏è</span>
                <span class="error-message">${escapeHtml(errorMsg)}</span>
              </div>
              <div style="display: flex; align-items: center; gap: 1rem;">
                <span class="error-count">${webhooks.length} webhook${webhooks.length > 1 ? 's' : ''}</span>
                <span class="expand-icon">‚ñº</span>
              </div>
            </div>
            <div class="error-group-content">
              ${webhooks.map(result => renderResultCard(result)).join('')}
            </div>
          </div>
        `;
      });

      return html;
    }

    function normalizeError(error) {
      // Remove IDs and timestamps to group similar errors
      return error
        .replace(/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/gi, '[ID]')
        .replace(/[0-9a-f]{24}/gi, '[ID]')
        .replace(/\d{13,}/g, '[TIMESTAMP]')
        .substring(0, 150); // Limit length
    }

    function toggleErrorGroup(groupId) {
      const group = document.getElementById(groupId);
      if (group) {
        group.classList.toggle('expanded');
      }
    }

    function renderMediaResults(results) {
      if (!results || results.length === 0) {
        return '<div class="no-results">No media results</div>';
      }

      let html = '<div class="media-grid">';
      results.forEach(item => {
        const isImage = item.type.toLowerCase() === 'image';
        const isVideo = item.type.toLowerCase() === 'video';

        html += `
          <div class="media-item">
            <div class="media-type">${escapeHtml(item.type)}</div>
            ${isImage ?
            `<div class="media-preview"><img src="${escapeHtml(item.url)}" alt="Result" loading="lazy" /></div>` :
            ''}
            ${isVideo ?
            `<div class="media-preview">
                <video controls muted loop preload="metadata" style="width: 100%; border-radius: 6px;">
                  <source src="${escapeHtml(item.url)}" type="video/mp4">
                  Your browser does not support video playback.
                </video>
              </div>` :
            ''}
            <a href="${escapeHtml(item.url)}" target="_blank" class="media-link">
              ${escapeHtml(item.url)}
            </a>
          </div>
        `;
      });
      html += '</div>';
      return html;
    }

    function renderError(error) {
      return `<div class="error-message">${escapeHtml(error || 'Unknown error')}</div>`;
    }

    function escapeHtml(str) {
      const div = document.createElement('div');
      div.textContent = str || '';
      return div.innerHTML;
    }

    async function retryWebhook(webhookId, slug, title) {
      const cardId = `card-${webhookId}`;
      const card = document.getElementById(cardId);

      if (!card) {
        console.error('Card not found:', cardId);
        return;
      }

      // Mark as retrying to prevent re-render from destroying state
      retryingWebhooks.add(webhookId);

      log(`Retrying webhook: ${webhookId}`, 'info');

      // Update card UI to show loading
      card.classList.remove('failed', 'success');
      card.classList.add('retrying');

      const statusBadge = card.querySelector('.status-badge');
      const retryBtn = card.querySelector('.retry-btn');
      const resultContent = card.querySelector('.result-content');

      if (!statusBadge || !retryBtn || !resultContent) {
        console.error('Card elements not found');
        retryingWebhooks.delete(webhookId);
        return;
      }

      // Force immediate UI update
      statusBadge.className = 'status-badge retrying';
      statusBadge.textContent = '‚è≥ Retrying...';
      retryBtn.disabled = true;
      retryBtn.textContent = '‚è≥ Running...';

      resultContent.innerHTML = '<div class="retry-status loading">üîÑ Testing webhook, please wait...</div>';

      // Force browser to repaint
      card.offsetHeight;

      // Add progress indicator that updates every 5 seconds
      let elapsedSeconds = 0;
      const progressInterval = setInterval(() => {
        elapsedSeconds += 5;
        const statusDiv = card.querySelector('.retry-status');
        if (statusDiv && statusDiv.classList.contains('loading')) {
          statusDiv.textContent = `üîÑ Testing webhook... ${elapsedSeconds}s elapsed (webhooks can take 1-5 minutes)`;
        }
      }, 5000);

      try {
        // Add timeout to prevent indefinite pending (5 minutes = 300 seconds)
        const controller = new AbortController();
        const timeoutId = setTimeout(() => {
          controller.abort();
          console.log('‚ö†Ô∏è Retry request timeout after 5 minutes');
        }, 5 * 60 * 1000);

        console.log('üì§ Retrying webhook:', webhookId);
        const response = await fetch(`${API_BASE_URL}/api/test`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ webhookId }),
          signal: controller.signal
        }).finally(() => clearTimeout(timeoutId));

        console.log('üì° Retry response:', response.status);

        if (!response.ok) {
          const errorText = await response.text();
          let errorMessage = `Server returned ${response.status}`;

          if (response.status === 401) {
            errorMessage = 'Authentication failed';
          } else if (response.status === 403) {
            errorMessage = 'Access denied';
          } else if (response.status === 500) {
            errorMessage = 'Server error';
          } else if (errorText) {
            try {
              const json = JSON.parse(errorText);
              errorMessage = json.error || json.message || errorMessage;
            } catch {
              errorMessage = errorText.substring(0, 200);
            }
          }

          throw new Error(errorMessage);
        }

        const data = await response.json();

        if (data.success) {
          // Use metadata from response if available
          const finalSlug = data.metadata?.slug || slug;
          const finalTitle = data.metadata?.title || title;
          const finalCategory = data.metadata?.category;
          
          // Update result in testResults array
          const resultIndex = testResults.findIndex(r => r.webhookId === webhookId);
          if (resultIndex !== -1) {
            testResults[resultIndex] = {
              webhookId,
              slug: finalSlug,
              title: finalTitle,
              category: finalCategory,
              status: 'success',
              results: data.results
            };
          }

          // Update card UI for success
          card.classList.remove('retrying', 'failed');
          card.classList.add('success');
          statusBadge.className = 'status-badge success';
          statusBadge.textContent = '‚úì Passed';
          retryBtn.style.display = 'none';
          resultContent.innerHTML = renderMediaResults(data.results);
          
          // Update the title to include category if available
          const webhookInfo = card.querySelector('.webhook-info');
          if (webhookInfo) {
            const webhookTitle = webhookInfo.querySelector('.webhook-title');
            if (webhookTitle && finalCategory) {
              const titleText = finalTitle || finalSlug || webhookId;
              webhookTitle.innerHTML = `${escapeHtml(titleText)} <span style="margin-left: 0.5rem; padding: 0.25rem 0.5rem; background: rgba(0, 212, 255, 0.15); color: var(--accent); border-radius: 4px; font-size: 0.75rem; font-weight: 500;">${escapeHtml(finalCategory)}</span>`;
            }
          }

          // Remove from retrying set
          retryingWebhooks.delete(webhookId);

          // Force repaint
          card.offsetHeight;

          log(`‚úì Retry successful for ${webhookId}`, 'success');
          updateStats();

          // Update history with the new results
          saveTestToHistory();
          log('üìä Test history updated with retry results', 'info');
        } else {
          // Update for failure
          card.classList.remove('retrying', 'success');
          card.classList.add('failed');
          statusBadge.className = 'status-badge failed';
          statusBadge.textContent = '‚úó Failed';
          retryBtn.disabled = false;
          retryBtn.textContent = 'üîÑ Retry';
          resultContent.innerHTML = renderError(data.error);

          // Remove from retrying set
          retryingWebhooks.delete(webhookId);

          // Force repaint
          card.offsetHeight;

          log(`‚úó Retry failed for ${webhookId}: ${data.error}`, 'error');

          // Also update history even if retry failed (to show the attempt)
          saveTestToHistory();
        }
      } catch (error) {
        // Handle timeout/abort errors specifically
        let errorMessage = error.message;
        if (error.name === 'AbortError') {
          errorMessage = 'Request timeout after 5 minutes. The webhook took too long to respond.';
        }

        // Update for error
        card.classList.remove('retrying', 'success');
        card.classList.add('failed');
        statusBadge.className = 'status-badge failed';
        statusBadge.textContent = '‚úó Failed';
        retryBtn.disabled = false;
        retryBtn.textContent = 'üîÑ Retry';
        resultContent.innerHTML = renderError(errorMessage);

        // Remove from retrying set
        retryingWebhooks.delete(webhookId);

        // Force repaint
        card.offsetHeight;

        log(`‚úó Retry error for ${webhookId}: ${errorMessage}`, 'error');

        // Update history even on error
        saveTestToHistory();
      } finally {
        // Always clear the progress interval
        clearInterval(progressInterval);
        console.log('‚úÖ Retry request completed for:', webhookId);
      }
    }

    function filterResults(filter) {
      currentFilter = filter;
      document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.filter === filter);
      });
      displayResults();
    }

    function toggleGrouping() {
      groupByError = !groupByError;
      const btn = document.getElementById('groupToggleBtn');
      btn.classList.toggle('active', groupByError);
      btn.textContent = groupByError ? 'üìã Ungroup Errors' : 'üìë Group Errors';
      displayResults();
    }

    // Redirect to all reports page
    function viewAllReports() {
      const reportsUrl = isLocal
        ? `${API_BASE_URL}/reports/index.html`
        : `${API_BASE_URL}/api/report?file=index.html`;

      console.log('üîó Redirecting to reports page:', reportsUrl);
      window.open(reportsUrl, '_blank');
    }

    function loadHistoricalTest(index) {
      const history = loadTestHistory();
      if (history[index]) {
        const historicalTest = history[index];

        // Generate HTML report for this historical test
        const html = generateHistoricalReportHTML(historicalTest);

        // Open in new tab
        const newTab = window.open('', '_blank');
        if (newTab) {
          newTab.document.write(html);
          newTab.document.close();
        }

        // Close dropdown
        const dropdown = document.getElementById('historyDropdown');
        const icon = document.getElementById('historyDropdownIcon');
        dropdown.classList.remove('visible');
        icon.style.transform = 'rotate(0deg)';
      }
    }

    function generateWebhookSection(result) {
      const statusClass = result.status === 'success' ? 'success' : 'failed';
      const title = result.title || result.slug || result.webhookId;

      let contentHTML = '';
      if (result.status === 'success' && result.results && result.results.length > 0) {
        contentHTML = '<div class="results-grid">';
        result.results.forEach(item => {
          const isImage = item.type.toLowerCase() === 'image';
          const isVideo = item.type.toLowerCase() === 'video';
          contentHTML += `
            <div class="result-card">
              <div class="media-preview">
                ${isImage ? `<img src="${item.url}" alt="Preview" class="preview-image" loading="lazy" />` : ''}
                ${isVideo ? `<video class="preview-video" muted loop playsinline preload="metadata"><source src="${item.url}" type="video/mp4">Your browser does not support video.</video>` : ''}
              </div>
              <div class="result-info">
                <span class="type-badge ${item.type.toLowerCase()}">${item.type}</span>
                <a href="${item.url}" target="_blank" rel="noopener noreferrer" class="url-link">${item.url.substring(0, 60)}...</a>
              </div>
            </div>
          `;
        });
        contentHTML += '</div>';
      } else if (result.error) {
        contentHTML = `<div class="error-message">‚ùå ${escapeHtml(result.error)}</div>`;
      }

      return `
        <section class="webhook-section">
          <div class="webhook-header">
            <div>
              <span class="webhook-slug">${escapeHtml(title)}</span>
              <br><span class="webhook-id">${escapeHtml(result.webhookId)}</span>
            </div>
            <span class="status-badge ${statusClass}">${statusClass === 'success' ? 'Passed' : 'Failed'}</span>
          </div>
          ${contentHTML}
        </section>
      `;
    }

    function generateFailedSections(failedResults) {
      if (failedResults.length === 0) return '';

      // Group by error
      const groups = {};
      failedResults.forEach(result => {
        const errorKey = normalizeError(result.error || 'Unknown error');
        if (!groups[errorKey]) {
          groups[errorKey] = [];
        }
        groups[errorKey].push(result);
      });

      const sortedGroups = Object.entries(groups).sort((a, b) => b[1].length - a[1].length);

      let html = '';
      sortedGroups.forEach(([errorMsg, webhooks]) => {
        const webhooksHTML = webhooks.map(r => generateWebhookSection(r)).join('');
        html += `
          <div class="error-category expanded">
            <div class="error-category-header">
              <span class="error-category-title">‚ö†Ô∏è ${escapeHtml(errorMsg)}</span>
              <span class="error-category-count">${webhooks.length} webhook${webhooks.length > 1 ? 's' : ''}</span>
            </div>
            <div class="error-category-items">
              ${webhooksHTML}
            </div>
          </div>
        `;
      });

      return html;
    }

    function generateHistoricalReportHTML(testRun) {
      const passedResults = testRun.results.filter(r => r.status === 'success');
      const failedResults = testRun.results.filter(r => r.status === 'failed');

      // Generate passed sections
      const passedHTML = passedResults.map(result => generateWebhookSection(result)).join('');

      // Generate failed sections (grouped by error)
      const failedHTML = generateFailedSections(failedResults);

      return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Test Results - ${testRun.date}</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet" media="print" onload="this.media='all'">
  <style>
    :root {
      --bg-primary: #0a0a0f;
      --bg-secondary: #12121a;
      --bg-tertiary: #1a1a26;
      --bg-card: #14141e;
      --text-primary: #f0f0f5;
      --text-secondary: #8888a0;
      --accent-primary: #7c3aed;
      --accent-secondary: #06b6d4;
      --accent-gradient: linear-gradient(135deg, #7c3aed 0%, #06b6d4 100%);
      --success: #10b981;
      --error: #ef4444;
      --border: rgba(255, 255, 255, 0.08);
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Space Grotesk', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      line-height: 1.6;
      min-height: 100vh;
      padding: 2rem;
    }
    .container { max-width: 1600px; margin: 0 auto; }
    header {
      text-align: center;
      margin-bottom: 2rem;
      padding: 3rem 2rem;
      background: var(--bg-card);
      border-radius: 24px;
      border: 1px solid var(--border);
      position: relative;
      overflow: hidden;
    }
    header::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: var(--accent-gradient);
    }
    h1 {
      font-size: 3rem;
      font-weight: 700;
      background: var(--accent-gradient);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 0.5rem;
      letter-spacing: -0.02em;
    }
    .timestamp {
      color: var(--text-secondary);
      font-size: 0.9rem;
      font-family: 'IBM Plex Mono', 'Courier New', Consolas, monospace;
    }
    .summary {
      display: flex;
      justify-content: center;
      gap: 1.5rem;
      margin-top: 2rem;
      flex-wrap: wrap;
    }
    .summary-item {
      padding: 1rem 2rem;
      border-radius: 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      font-weight: 600;
      font-size: 1.1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .summary-item.success {
      border-color: var(--success);
      color: var(--success);
      box-shadow: 0 0 20px rgba(16, 185, 129, 0.15);
    }
    .summary-item.failure {
      border-color: var(--error);
      color: var(--error);
      box-shadow: 0 0 20px rgba(239, 68, 68, 0.15);
    }
    .summary-item.total {
      border-color: var(--accent-primary);
      color: var(--text-primary);
    }
    .tabs-container { margin-bottom: 2rem; }
    .tab-buttons {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
      background: var(--bg-card);
      padding: 0.5rem;
      border-radius: 16px;
      border: 1px solid var(--border);
      width: fit-content;
    }
    .tab-button {
      padding: 0.75rem 1.5rem;
      border: none;
      background: transparent;
      color: var(--text-secondary);
      font-family: 'Space Grotesk', sans-serif;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      border-radius: 12px;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .tab-button:hover {
      color: var(--text-primary);
      background: var(--bg-tertiary);
    }
    .tab-button.active {
      background: var(--accent-gradient);
      color: white;
    }
    .tab-button.success-tab.active { background: var(--success); }
    .tab-button.failed-tab.active { background: var(--error); }
    .tab-count {
      background: rgba(255, 255, 255, 0.2);
      padding: 0.15rem 0.5rem;
      border-radius: 8px;
      font-size: 0.85rem;
    }
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    .error-category { margin-bottom: 2rem; }
    .error-category-header {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-left: 4px solid var(--error);
      border-radius: 12px;
      padding: 1rem 1.5rem;
      margin-bottom: 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      transition: background 0.2s;
    }
    .error-category-header:hover { background: var(--bg-tertiary); }
    .error-category-title {
      font-size: 1rem;
      font-weight: 600;
      color: var(--error);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .error-category-count {
      background: rgba(239, 68, 68, 0.15);
      color: var(--error);
      padding: 0.25rem 0.75rem;
      border-radius: 8px;
      font-size: 0.85rem;
      font-weight: 600;
    }
    .error-category-items { display: none; padding-left: 1rem; }
    .error-category.expanded .error-category-items { display: block; }
    .error-category-header::after {
      content: '‚ñ∂';
      font-size: 0.7rem;
      color: var(--text-secondary);
      transition: transform 0.2s;
    }
    .error-category.expanded .error-category-header::after { transform: rotate(90deg); }
    .webhook-section {
      margin-bottom: 1.5rem;
      background: var(--bg-card);
      border-radius: 16px;
      border: 1px solid var(--border);
      overflow: hidden;
    }
    .webhook-header {
      padding: 1.25rem 1.5rem;
      background: var(--bg-tertiary);
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 1rem;
    }
    .webhook-slug {
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--text-primary);
    }
    .webhook-id {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.75rem;
      color: var(--accent-secondary);
      opacity: 0.8;
    }
    .status-badge {
      padding: 0.35rem 1rem;
      border-radius: 20px;
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .status-badge.success {
      background: rgba(16, 185, 129, 0.15);
      color: var(--success);
      border: 1px solid var(--success);
    }
    .status-badge.failed {
      background: rgba(239, 68, 68, 0.15);
      color: var(--error);
      border: 1px solid var(--error);
    }
    .error-message {
      padding: 1.25rem 1.5rem;
      background: rgba(239, 68, 68, 0.08);
      color: var(--error);
      font-size: 0.9rem;
      border-left: 3px solid var(--error);
    }
    .results-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
      gap: 1rem;
      padding: 1.5rem;
    }
    .result-card {
      background: var(--bg-tertiary);
      border-radius: 12px;
      border: 1px solid var(--border);
      overflow: hidden;
    }
    .media-preview {
      position: relative;
      width: 100%;
      aspect-ratio: 16 / 9;
      background: var(--bg-primary);
      overflow: hidden;
    }
    .preview-image, .preview-video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .preview-video { cursor: pointer; }
    .result-info { padding: 1rem; }
    .type-badge {
      display: inline-block;
      padding: 0.25rem 0.6rem;
      border-radius: 4px;
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      margin-bottom: 0.5rem;
    }
    .type-badge.image {
      background: rgba(6, 182, 212, 0.15);
      color: var(--accent-secondary);
    }
    .type-badge.video {
      background: rgba(124, 58, 237, 0.15);
      color: var(--accent-primary);
    }
    .url-link {
      color: var(--text-secondary);
      text-decoration: none;
      font-size: 0.75rem;
      font-family: 'IBM Plex Mono', monospace;
      word-break: break-all;
      display: block;
    }
    .url-link:hover { color: var(--accent-secondary); }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>üé® Magic Flow Results</h1>
      <p class="timestamp">Generated: ${testRun.date}</p>
      <div class="summary">
        <div class="summary-item success">‚úì ${testRun.passed} Passed</div>
        <div class="summary-item failure">‚úó ${testRun.failed} Failed</div>
        <div class="summary-item total">üìä ${testRun.totalWebhooks} Total</div>
      </div>
    </header>

    <div class="tabs-container">
      <div class="tab-buttons">
        <button type="button" class="tab-button success-tab active" data-tab="passed">
          ‚úì Passed <span class="tab-count">${testRun.passed}</span>
        </button>
        <button type="button" class="tab-button failed-tab" data-tab="failed">
          ‚úó Failed <span class="tab-count">${testRun.failed}</span>
        </button>
      </div>

      <div id="passed" class="tab-content active">
        ${passedHTML || '<div style="padding: 3rem; text-align: center; color: var(--text-secondary);">No passed tests</div>'}
      </div>

      <div id="failed" class="tab-content">
        ${failedHTML || '<div style="padding: 3rem; text-align: center; color: var(--text-secondary);">No failed tests</div>'}
      </div>
    </div>
  </div>

  <script>
    // Tab switching
    document.querySelectorAll('.tab-button').forEach(button => {
      button.addEventListener('click', function() {
        const tabId = this.dataset.tab;
        document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
        this.classList.add('active');
        document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
        document.getElementById(tabId).classList.add('active');
      });
    });

    // Error category toggle
    document.querySelectorAll('.error-category-header').forEach(header => {
      header.addEventListener('click', function() {
        this.parentElement.classList.toggle('expanded');
      });
    });

    // Play video on hover
    document.querySelectorAll('.preview-video').forEach(video => {
      video.addEventListener('mouseenter', function() { this.play().catch(() => {}); });
      video.addEventListener('mouseleave', function() { this.pause(); this.currentTime = 0; });
    });
  <` + `/script>
<` + `/body>
<` + `/html>`;
    }


    function clearResults() {
      console.log('clearResults() called explicitly by user');
      testResults = [];
      isTestRunning = false;
      testCompleted = false;
      totalWebhooksCount = 0;
      retryingWebhooks.clear();
      clearSavedResults();

      // Stop duration timer
      stopDuration();
      startTime = null;

      updateStats();
      document.getElementById('resultsGrid').innerHTML =
        '<div class="no-results">Click "Run All Webhook Tests" to begin testing</div>';
      document.getElementById('logsContainer').innerHTML = '';
      document.getElementById('progressSection').classList.remove('visible');
      document.getElementById('reportLinkSection').classList.remove('visible');
      document.getElementById('resumeBtn').style.display = 'none';
      document.getElementById('duration').textContent = '0s';
    }

    async function runManualTests() {
      const input = document.getElementById('manualWebhookIds');
      const webhookIds = input.value.trim();

      if (!webhookIds) {
        alert('Please enter at least one webhook ID');
        return;
      }

      // Parse comma-separated IDs
      const ids = webhookIds.split(',').map(id => id.trim()).filter(id => id.length > 0);

      if (ids.length === 0) {
        alert('Please enter valid webhook IDs');
        return;
      }

      log(`Starting manual test for ${ids.length} webhook(s)...`, 'info');
      await runTests(ids, `Testing ${ids.length} selected webhook(s)`);
    }

    async function runAllTests() {
      console.log('runAllTests() called');

      const btn = document.getElementById('runAllBtn');
      const btnText = document.getElementById('runBtnText');

      if (btn.disabled) {
        console.log('Button disabled, returning');
        return;
      }

      if (isTestRunning) {
        console.log('Test already running, returning');
        return;
      }

      // Only reset if user explicitly wants to start fresh
      if (testResults.length > 0) {
        console.log('testResults has data, asking for confirmation');
        if (!confirm('This will clear current results. Continue?')) {
          console.log('User cancelled, not starting test');
          return;
        }
      }

      console.log('Calling runTests() with null (all webhooks)');
      await runTests(null, 'Running all webhook tests');
      console.log('runAllTests() finished');
    }

    async function runTests(specificWebhookIds = null, logMessage = 'Starting tests') {
      console.log('=== runTests() START ===');
      console.log('specificWebhookIds:', specificWebhookIds);
      console.log('Current testResults.length:', testResults.length);
      console.log('isTestRunning:', isTestRunning);

      const btn = document.getElementById('runAllBtn');
      const btnText = document.getElementById('runBtnText');

      // Prevent multiple simultaneous runs
      if (isTestRunning) {
        console.log('Test already running, EXITING runTests()');
        return;
      }

      // Reset
      console.log('runTests: Clearing testResults array');
      testResults = [];
      testCompleted = false;
      retryingWebhooks.clear();
      clearSavedResults();
      clearInterval(durationInterval);
      startTime = Date.now();
      durationInterval = setInterval(updateDuration, 1000);
      isTestRunning = true;
      console.log('runTests: isTestRunning set to true');

      btn.disabled = true;
      btnText.innerHTML = '‚è≥ Running Tests... <span class="spinner"></span>';

      document.getElementById('progressSection').classList.add('visible');
      document.getElementById('reportLinkSection').classList.remove('visible');
      document.getElementById('logsContainer').innerHTML = '';
      document.getElementById('resultsGrid').innerHTML = '<div class="no-results">Waiting for results...</div>';

      try {
        log(logMessage, 'info');
        if (!specificWebhookIds) {
          log('Fetching webhook list from API...', 'info');
        } else {
          log(`Testing ${specificWebhookIds.length} specific webhook(s)`, 'info');
        }

        const response = await fetch(`${API_BASE_URL}/api/test-all`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ webhookIds: specificWebhookIds })
        });

        if (!response.ok) {
          const errorText = await response.text();
          let errorMessage = `Server Error(${response.status})`;

          // Parse error messages for better UX
          if (response.status === 401) {
            errorMessage = 'üîê Authentication Failed: Invalid API token';
          } else if (response.status === 403) {
            errorMessage = 'üö´ Access Denied: Insufficient permissions';
          } else if (response.status === 404) {
            errorMessage = '‚ùì Not Found: API endpoint not available';
          } else if (response.status === 500) {
            errorMessage = 'üí• Server Error: Something went wrong on the server';
          } else if (response.status === 503) {
            errorMessage = '‚è∏Ô∏è Service Unavailable: Server is temporarily down';
          } else if (errorText) {
            try {
              const json = JSON.parse(errorText);
              errorMessage = json.error || json.message || errorMessage;
            } catch {
              errorMessage = errorText.substring(0, 200);
            }
          }

          throw new Error(errorMessage);
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder();

        // Track last data received for timeout detection
        let lastDataTime = Date.now();
        const CONNECTION_TIMEOUT = 60000; // 60 seconds without any data = connection lost

        // Timeout checker
        const timeoutChecker = setInterval(() => {
          const timeSinceLastData = Date.now() - lastDataTime;
          if (timeSinceLastData > CONNECTION_TIMEOUT) {
            log('‚ö†Ô∏è Connection timeout - no data received for 60 seconds', 'warning');
            clearInterval(timeoutChecker);
            reader.cancel();
          }
        }, 10000); // Check every 10 seconds

        while (true) {
          const { done, value } = await reader.read();
          if (done) {
            clearInterval(timeoutChecker);
            break;
          }

          const chunk = decoder.decode(value);
          const lines = chunk.split('\n');

          for (const line of lines) {
            if (line.startsWith('data: ')) {
              lastDataTime = Date.now(); // Update last data time
              const data = JSON.parse(line.slice(6));

              // Handle heartbeat to keep connection alive
              if (data.type === 'heartbeat') {
                // Silent heartbeat - just update timestamp
                continue;
              }

              if (data.type === 'connected') {
                log('‚úì Stream connected', 'success');
                continue;
              }

              if (data.type === 'init') {
                totalWebhooksCount = data.total;
                log(`Found ${data.total} webhooks to test`, 'info');
                updateProgress(0, data.total);
                saveResults();
              } else if (data.type === 'progress') {
                log(`Testing: ${data.webhook} (${data.current}/${data.total})`, 'info');
                updateProgress(data.current, data.total);
              } else if (data.type === 'result') {
                console.log('Received result:', data.result);
                testResults.push(data.result);
                console.log('testResults.length is now:', testResults.length);
                const status = data.result.status === 'success' ? 'success' : 'error';
                log(`${data.result.status === 'success' ? '‚úì' : '‚úó'} ${data.result.webhookId}`, status);
                updateStats();
                displayResults();
                console.log('displayResults() called after result #', testResults.length);
              } else if (data.type === 'complete') {
                console.log('=== COMPLETE EVENT RECEIVED ===');
                console.log('testResults.length:', testResults.length);
                console.log('data.passed:', data.passed, 'data.failed:', data.failed);

                log(`Tests completed! ${data.passed} passed, ${data.failed} failed`, 'success');

                // Mark as completed FIRST
                testCompleted = true;
                isTestRunning = false;

                // Stop duration timer
                stopDuration();
                totalWebhooksCount = 0;

                // DON'T clear saved results - keep them for page reload!
                // Save completion state so timer doesn't restart on reload
                localStorage.setItem('testCompleted', 'true');
                localStorage.removeItem('isTestRunning');
                localStorage.removeItem('totalWebhooksCount');

                // Save results to persist the testCompleted state
                saveResults();

                document.getElementById('resumeBtn').style.display = 'none';

                console.log('Before displaying results. testResults.length:', testResults.length);

                // Display results IMMEDIATELY (no timeout)
                displayResults();

                // Ensure results section is visible
                const resultsSection = document.getElementById('resultsSection');
                if (resultsSection) {
                  resultsSection.style.display = 'block';
                  console.log('Results section forced to display: block');
                }

                console.log('After displayResults(). Grid children:', document.getElementById('resultsGrid').children.length);

                // Keep progress section visible with final state
                document.getElementById('progressSection').classList.add('visible');

                // Save test to history
                saveTestToHistory();

                // Show report link if available
                if (data.reportPath) {
                  const reportFileName = data.reportPath.split('/').pop();
                  // Use API route for shareable URLs
                  const shareableUrl = isLocal
                    ? `${API_BASE_URL}/reports/${reportFileName}`
                    : `${API_BASE_URL}/api/report?file=${reportFileName}`;

                  document.getElementById('reportLink').href = shareableUrl;
                  document.getElementById('reportLink').dataset.shareUrl = shareableUrl;
                  document.getElementById('reportLinkSection').classList.add('visible');
                  document.getElementById('shareReportBtn').style.display = 'inline-block';
                  log(`Report saved: ${reportFileName}`, 'success');
                  log(`üìé Shareable link: ${shareableUrl}`, 'info');
                }

              } else if (data.type === 'error') {
                log(`Error: ${data.message}`, 'error');
              } else if (data.type === 'info') {
                log(data.message, 'info');
              }
            }
          }
        }

        // Clean up timeout checker when stream ends normally
        clearInterval(timeoutChecker);

      } catch (error) {
        // Clean up timeout checker on error
        if (typeof timeoutChecker !== 'undefined') {
          clearInterval(timeoutChecker);
        }

        log(`Fatal error: ${error.message}`, 'error');
        console.error('Error in runTests:', error);
        isTestRunning = false;

        // Determine error type for better messaging
        let errorIcon = '‚ö†Ô∏è';
        let errorTitle = 'Test Failed to Start';
        let errorDetails = error.message;
        let actionButton = '<button type="button" onclick="location.reload()" style="padding: 0.75rem 1.5rem; background: var(--accent); color: var(--bg-primary); border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">üîÑ Reload Page</button>';

        if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
          errorIcon = 'üîå';
          errorTitle = 'Connection Failed';
          errorDetails = 'Unable to connect to the server. Please check your internet connection or verify the server is running.';
        } else if (error.message.includes('Authentication')) {
          errorIcon = 'üîê';
          errorTitle = 'Authentication Error';
          errorDetails = error.message;
        } else if (error.message.includes('CORS')) {
          errorIcon = 'üö´';
          errorTitle = 'CORS Error';
          errorDetails = 'Cross-origin request blocked. Server may need CORS configuration.';
        }

        // Show user-friendly error message
        const grid = document.getElementById('resultsGrid');
        grid.innerHTML = `
          <div style="padding: 3rem; text-align: center; background: var(--bg-tertiary); border-radius: 12px; border: 1px solid var(--error);">
            <div style="font-size: 3rem; margin-bottom: 1rem;">${errorIcon}</div>
            <div style="font-size: 1.2rem; color: var(--error); margin-bottom: 1rem; font-weight: 600;">
              ${errorTitle}
            </div>
            <div style="color: var(--text-secondary); margin-bottom: 1.5rem; max-width: 500px; margin-left: auto; margin-right: auto;">
              ${escapeHtml(errorDetails)}
            </div>
            ${actionButton}
          </div>
        `;
      } finally {
        console.log('=== FINALLY BLOCK ===');
        console.log('isTestRunning:', isTestRunning);
        console.log('testCompleted:', testCompleted);
        console.log('testResults.length:', testResults.length);

        btn.disabled = false;
        btnText.textContent = 'üöÄ Run All Webhook Tests';

        // DON'T clear or hide anything in finally - results should persist!
        console.log('Finally block complete. Results should be visible.');
      }
    }

    async function resumeTests() {
      const btn = document.getElementById('resumeBtn');
      const runBtn = document.getElementById('runAllBtn');

      if (btn.disabled || runBtn.disabled) return;

      btn.disabled = true;
      runBtn.disabled = true;
      btn.textContent = '‚è≥ Resuming...';
      isTestRunning = true;

      log('Resuming test from where it was interrupted...', 'info');

      // Get IDs of already tested webhooks
      const testedWebhookIds = new Set(testResults.map(r => r.webhookId));
      log(`Already tested: ${testedWebhookIds.size} webhooks`, 'info');

      document.getElementById('progressSection').classList.add('visible');

      try {
        // Fetch all webhooks
        log('Fetching full webhook list...', 'info');
        const response = await fetch(`${API_BASE_URL}/api/test-all`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' }
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${await response.text()}`);
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let allWebhooks = [];
        let receivingInit = true;

        // Track last data received for timeout detection
        let lastDataTime = Date.now();
        const CONNECTION_TIMEOUT = 60000; // 60 seconds without any data = connection lost

        // Timeout checker
        const timeoutChecker = setInterval(() => {
          const timeSinceLastData = Date.now() - lastDataTime;
          if (timeSinceLastData > CONNECTION_TIMEOUT) {
            log('‚ö†Ô∏è Connection timeout - no data received for 60 seconds', 'warning');
            clearInterval(timeoutChecker);
            reader.cancel();
          }
        }, 10000); // Check every 10 seconds

        while (true) {
          const { done, value } = await reader.read();
          if (done) {
            clearInterval(timeoutChecker);
            break;
          }

          const chunk = decoder.decode(value);
          const lines = chunk.split('\n');

          for (const line of lines) {
            if (line.startsWith('data: ')) {
              lastDataTime = Date.now(); // Update last data time
              const data = JSON.parse(line.slice(6));

              // Handle heartbeat to keep connection alive
              if (data.type === 'heartbeat') {
                continue;
              }

              if (data.type === 'connected') {
                log('‚úì Stream connected', 'success');
                continue;
              }

              if (data.type === 'init') {
                totalWebhooksCount = data.total;
                log(`Total webhooks: ${data.total}`, 'info');
                log(`Remaining to test: ${data.total - testedWebhookIds.size}`, 'info');
                updateProgress(testedWebhookIds.size, data.total);
                saveResults();
                receivingInit = false;
              } else if (data.type === 'result') {
                // Only process if we haven't tested this webhook yet
                if (!testedWebhookIds.has(data.result.webhookId)) {
                  testResults.push(data.result);
                  testedWebhookIds.add(data.result.webhookId);

                  const status = data.result.status === 'success' ? 'success' : 'error';
                  log(`${data.result.status === 'success' ? '‚úì' : '‚úó'} ${data.result.webhookId}`, status);

                  updateStats();
                  displayResults();
                  updateProgress(testedWebhookIds.size, totalWebhooksCount);
                }
              } else if (data.type === 'progress') {
                // Update progress
                updateProgress(data.current, data.total);
              } else if (data.type === 'complete') {
                log(`Resume completed! Total: ${testedWebhookIds.size} webhooks`, 'success');
                testCompleted = true;
                isTestRunning = false;

                // Stop duration timer
                stopDuration();
                totalWebhooksCount = 0;

                // DON'T clear saved results - keep them for page reload!
                // Save completion state so timer doesn't restart on reload
                localStorage.setItem('testCompleted', 'true');
                localStorage.removeItem('isTestRunning');
                localStorage.removeItem('totalWebhooksCount');

                // Save results to persist the testCompleted state
                saveResults();

                btn.style.display = 'none';

                // Ensure final results are displayed with delay
                setTimeout(() => {
                  console.log('Resume complete, displaying final results');
                  displayResults();

                  const resultsSection = document.getElementById('resultsSection');
                  if (resultsSection) {
                    resultsSection.style.display = 'block';
                  }

                  resultsSection?.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }, 100);

                // Keep progress section visible with final state
                document.getElementById('progressSection').classList.add('visible');

                // Save test to history
                saveTestToHistory();

                if (data.reportPath) {
                  const reportFileName = data.reportPath.split('/').pop();
                  // Use API route for shareable URLs
                  const shareableUrl = isLocal
                    ? `${API_BASE_URL}/reports/${reportFileName}`
                    : `${API_BASE_URL}/api/report?file=${reportFileName}`;

                  document.getElementById('reportLink').href = shareableUrl;
                  document.getElementById('reportLink').dataset.shareUrl = shareableUrl;
                  document.getElementById('reportLinkSection').classList.add('visible');
                  document.getElementById('shareReportBtn').style.display = 'inline-block';
                  log(`Report saved: ${reportFileName}`, 'success');
                  log(`üìé Shareable link: ${shareableUrl}`, 'info');
                }

              } else if (data.type === 'error') {
                log(`Error: ${data.message}`, 'error');
              } else if (data.type === 'info') {
                log(data.message, 'info');
              }
            }
          }
        }

        // Clean up timeout checker when stream ends normally
        clearInterval(timeoutChecker);

      } catch (error) {
        // Clean up timeout checker on error
        if (typeof timeoutChecker !== 'undefined') {
          clearInterval(timeoutChecker);
        }

        log(`Resume error: ${error.message}`, 'error');
        console.error('Error in resumeTests:', error);
        isTestRunning = false;

        // Show error in results grid
        const grid = document.getElementById('resultsGrid');
        grid.innerHTML = `
          <div style="padding: 2rem; text-align: center; background: var(--bg-tertiary); border-radius: 12px; border: 1px solid var(--error);">
            <div style="font-size: 2rem; margin-bottom: 0.5rem;">‚ö†Ô∏è</div>
            <div style="font-size: 1rem; color: var(--error); margin-bottom: 0.5rem; font-weight: 600;">
              Resume Failed
            </div>
            <div style="color: var(--text-secondary); font-size: 0.9rem;">
              ${escapeHtml(error.message)}
            </div>
          </div>
        `;
      } finally {
        btn.disabled = false;
        runBtn.disabled = false;
        btn.textContent = '‚ñ∂Ô∏è Resume Test';
      }
    }

    // Function to copy shareable report link to clipboard
    function shareReport() {
      const reportLink = document.getElementById('reportLink');
      const shareUrl = reportLink.dataset.shareUrl || reportLink.href;
      const btn = document.getElementById('shareReportBtn');

      if (!shareUrl) {
        log('No report URL available to share', 'error');
        return;
      }

      // Copy to clipboard
      navigator.clipboard.writeText(shareUrl).then(() => {
        // Show success feedback
        const originalText = btn.textContent;
        btn.textContent = '‚úÖ Link Copied!';
        btn.style.background = 'var(--success)';

        log(`üìã Shareable link copied to clipboard: ${shareUrl}`, 'success');

        // Reset button after 2 seconds
        setTimeout(() => {
          btn.textContent = originalText;
          btn.style.background = 'var(--accent)';
        }, 2000);
      }).catch(err => {
        console.error('Failed to copy to clipboard:', err);
        log('Failed to copy link. Please copy manually from logs.', 'error');

        // Fallback: Select the link text
        const range = document.createRange();
        range.selectNode(reportLink);
        window.getSelection().removeAllRanges();
        window.getSelection().addRange(range);
      });
    }
  </script>
</body>

</html>
